This started as a code blogging solution, but then I found [Micro.blog](https://micro.blog/) and I got *all the way over* building my own blogging platform. The part of this original plan worth keeping, however IMO, is a C# [GitHub API client](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/GitHubApiClient.cs) implemented with [Refit](https://github.com/reactiveui/refit). My Refit interface is [here](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/Interfaces/IGitHubApi.cs). This is certainly a work in progress because I've implemented only a few methods, and the whole [GitHub API](https://docs.github.com/en/free-pro-team@latest/rest) is rather large. I'm not sure how much more I'll do in the short term. Yes I'm aware of [Octokit](https://www.nuget.org/packages/Octokit), GitHub's own API client. If you needed something full-featured, you'd use that.

I wanted more practice using Refit because there are some slightly tricky things about getting it working.

- I'm using access token authentication. To get Refit to use a token for authentication, I added an [AuthorizationHeaderValueGetter](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/GitHubApiClient.cs#L44) delegate, which simply returns the token that was passed through the client object constructor. The less obvious part is that you need to add a `[Headers]` attribute on your Refit interface that is formed a certain way. In particular, you need [Authorization: token](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/Interfaces/IGitHubApi.cs#L8) as one of the headers. It appears that the token you provide gets concatenated to that header. There are a couple other headers GitHub looks for: `User-Agent` (required) and `Accept` (optional).

- A frustration I ran into was that I could get Postman to work with sample API calls, but then I wasn't sure how to form the C#-Refit equivalent exactly. I had to just try several things regarding that `[Header]` attribute. I eventually got it working.

- Note that my Refit [interface](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/Interfaces/IGitHubApi.cs#L9) itself is `internal`. This is because the raw API endpoints aren't the easiest things to use from a C# perspective. There are a couple reasons for this. For one, they use string arguments where `enum`s would work better. My [public client object](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/GitHubApiClient.cs) uses private enum converter methods [like this](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/GitHubApiClient.cs#L85). Second, to get all items in a paginated list, you need some kind of wrapper method that [enumerates all pages](https://github.com/adamfoneil/GitHubApi/blob/master/GitHubApi.Library/GitHubApiClient.cs#L62).

- For testing purposes, I'm using my own access token, which I need to keep out of source control. So, if you want to clone and run this repo, you'll need to create your own access token and set it up in the repo just so. Create a json file called **github.json** inside a Config folder. Your config file should look like this:

![img](https://adamosoftware.blob.core.windows.net/images/github-api-config.png)

The config content is accessed through this [Config](https://github.com/adamfoneil/GitHubApi/blob/master/Api.Tests/Helpers/Config.cs) static property, and then I have a [factory method](https://github.com/adamfoneil/GitHubApi/blob/master/Api.Tests/GitHubIntegration.cs#L46) for my client object that uses this configuration. Also note that I use a couple hard-coded repo names that are not likely to work for you without changes, so bear that in mind.

# Micro.blog
I haven't ruled out creating a code blogging experience that combines a GitHub commit history browser with a blogging feature that posts to [Micro.blog](https://micro.blog/). Micro.blog offers several [API topics](https://help.micro.blog/2018/api-overview/), so this is another chance to get more practice with Refit implementing a Micro.blog client. My approach to this is here: [MicropubApi.Library](https://github.com/adamfoneil/GitHubApi/tree/master/MicropubApi.Library). Note that `Micropub` is a [W3C recommendation](https://www.w3.org/TR/micropub/) while Micro.pub just happens to be the provider I'm using. My approach has a [hardcoded reference](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/MicropubApiClient.cs#L25) to Micro.pub, when it should probably be an argument you can pass. Maybe later! For now, the key parts of my solution are:

- a folder of [Internal](https://github.com/adamfoneil/GitHubApi/tree/master/MicropubApi.Library/Internal) components: [Interfaces](https://github.com/adamfoneil/GitHubApi/tree/master/MicropubApi.Library/Internal/Interfaces), [Requests](https://github.com/adamfoneil/GitHubApi/tree/master/MicropubApi.Library/Internal/Requests), and [Responses](https://github.com/adamfoneil/GitHubApi/tree/master/MicropubApi.Library/Internal/Responses).
- a folder of public [Models](https://github.com/adamfoneil/GitHubApi/tree/master/MicropubApi.Library/Models)
- the main public [client object](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/MicropubApiClient.cs), which is what you'd use to interact with the backend blogging service.
- [integration tests](https://github.com/adamfoneil/GitHubApi/blob/master/Api.Tests/MicropubTests.cs) provide my main debug experience

## Public vs Internal
Note that I try to keep a clear separation between internal and public components. (Although I don't have a `Public` folder/namespace, the convention I'm following is that anything not under the `Internal` folder is intended to be public.) As usual, I recommend keeping Refit interfaces internal because they map to the raw endpoints of the backend service. As such, they use arguments and member names that aren't necessarily what I want as a client of the service want to see.

For example, the internal [Feed](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/Internal/Responses/Feed.cs) object uses lower-case properties that come straight off the json of the backend service, and there's more info than I need as a C# developer. That's why there's a [ToEntry](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/Internal/Responses/Feed.cs#L24) method that extracts only the useful part of it for public use that follows the naming conventions I want.

When [posting a new entry](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/MicropubApiClient.cs#L37), I do a similar public-to-internal conversion that takes a public model [NewEntry](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/Models/NewEntry.cs) and [converts](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/Internal/Requests/InternalEntry.cs#L15) it to its internal equivalent -- again, because of mismatches in naming between how the Micropub format names things and how I was a C# dev want to name things.

## Refit Debugging
I'm still figuring out things you can do with Refit. It has attributes you apply on interface methods and arguments to craft the underlying http messaging. Figuring out the right set of attributes for a given API requirement can be tricky. You'll notice that my [AddPostAsync](https://github.com/adamfoneil/GitHubApi/blob/master/MicropubApi.Library/Internal/Interfaces/IMicropubApi.cs#L12) method uses the `[Query]` attribute. This is so the properties of the object being posted get transformed into a query string per a Micropub requirement. I use a combination of Postman and Fiddler to try sample requests, and then Fiddler to look at the underlying http traffic. I'm surprised this is not more seamless in Visual Studio. Bouncing between documentation, Fiddler, Postman, and Refit to get an API working is not a great experience. That's why I'm taking every opportunity to practice with Refit.
